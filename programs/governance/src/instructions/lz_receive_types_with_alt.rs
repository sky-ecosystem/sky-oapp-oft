// SPDX-License-Identifier: Apache-2.0
use crate::msg_codec::GovernanceMessage;
use crate::*;
use oapp::endpoint_cpi::{get_accounts_for_clear, LzAccount};
use oapp::{endpoint::ID as ENDPOINT_ID, LzReceiveParams};
use solana_program::address_lookup_table::state::AddressLookupTable;

// Make sure we're using Anchor's Pubkey consistently
use anchor_lang::prelude::*;

/// LzReceiveTypes instruction provides a list of accounts that are used in the LzReceive
/// instruction. The list of accounts required by this LzReceiveTypes instruction can be found
/// from the specific PDA account that is generated by the LZ_RECEIVE_TYPES_SEED.
/// from the specific PDA account that is generated by the LZ_RECEIVE_TYPES_SEED.
#[derive(Accounts)]
pub struct LzReceiveTypesWithAlt<'info> {
    #[account(seeds = [GOVERNANCE_SEED, &governance.id.to_be_bytes()], bump = governance.bump)]
    pub governance: Account<'info, Governance>,

    #[account(
        seeds = [LZ_RECEIVE_ALT_SEED, &governance.key().to_bytes()],
        bump = governance.bump,
    )]
    pub lz_receive_alt: Account<'info, LzReceiveAlt>,

    #[account(address = lz_receive_alt.address)]
    pub lookup_table: AccountInfo<'info>,

    #[account(address = solana_program::address_lookup_table::program::ID)]
    pub address_lookup_table_program: AccountInfo<'info>,
}

impl LzReceiveTypesWithAlt<'_> {
    /// The list of accounts should follow the rules below:
    /// 1. Include all the accounts that are used in the LzReceive instruction, including the
    /// accounts that are used by the Endpoint program.
    /// 2. Set the account is a signer with ZERO address if the LzReceive instruction needs a payer
    /// to pay fee, like rent.
    /// 3. Set the account is writable if the LzReceive instruction needs to modify the account.
    pub fn apply(
        ctx: &Context<LzReceiveTypesWithAlt>,
        params: &LzReceiveParams,
    ) -> Result<Vec<LzAccountAlt>> {
        let lookup_table = &ctx.accounts.lookup_table;
        let alt_addresses =
            AddressLookupTable::deserialize(*lookup_table.try_borrow_data().unwrap())
                .unwrap()
                .addresses
                .to_vec();

        // There are two accounts that are used in the LzReceive instruction,
        // except those accounts for endpoint program.
        // The first account is the count account, that is the fixed one.
        let governance = ctx.accounts.governance.key();

        // The second account is the remote account, we find it by the params.src_eid.
        let seeds = [
            REMOTE_SEED,
            &governance.to_bytes(),
            &params.src_eid.to_be_bytes(),
        ];
        let (remote, _) = Pubkey::find_program_address(&seeds, ctx.program_id);
        let cpi_authority = Pubkey::create_program_address(&[CPI_AUTHORITY_SEED, &governance.to_bytes(), &GovernanceMessage::decode_origin_caller(&params.message).unwrap(), &[ctx.accounts.governance.bump]], ctx.program_id).unwrap();

        let governance_message: GovernanceMessage = GovernanceMessage::from_bytes(&params.message)?;

        // accounts 0..4
        let mut accounts = vec![
            // payer
            LzAccount {
                pubkey: Pubkey::default(),
                is_signer: true,
                is_writable: true,
            }, // 0
            // governance
            LzAccount {
                pubkey: governance,
                is_signer: false,
                is_writable: true,
            },
            // remote
            LzAccount {
                pubkey: remote,
                is_signer: false,
                is_writable: false,
            },
            // cpi authority
            LzAccount {
                pubkey: cpi_authority,
                is_signer: false,
                is_writable: true,
            },
            // program
            LzAccount {
                pubkey: governance_message.program_id,
                is_signer: false,
                is_writable: false,
            },
            // system program
            LzAccount {
                pubkey: solana_program::system_program::id(),
                is_signer: false,
                is_writable: false,
            },
        ];

        // accounts 5..12
        // append the accounts for the clear ix
        let accounts_for_clear = get_accounts_for_clear(
            ENDPOINT_ID,
            &governance,
            params.src_eid,
            &params.sender,
            params.nonce,
        );
        accounts.extend(accounts_for_clear);

        // accounts 13..
        // Add gov msg accounts individually
        accounts.extend(
            governance_message
                .accounts
                .iter()
                .filter(|acc| {
                    acc.pubkey != CPI_AUTHORITY_PLACEHOLDER
                        && acc.pubkey != PAYER_PLACEHOLDER
                        && acc.pubkey != governance_message.program_id
                })
                .map(|acc| LzAccount {
                    pubkey: acc.pubkey,
                    is_signer: false,
                    is_writable: acc.is_writable,
                }),
        );

        // Convert LzAccount to LzAccountAlt, using ALT index when possible
        let lz_account_alts = accounts
            .iter()
            .map(|account| {
                // Try to find the account in the ALT
                let alt_index = alt_addresses
                    .iter()
                    .position(|&alt_addr| alt_addr.to_bytes() == account.pubkey.to_bytes());

                match alt_index {
                    Some(index) => {
                        // Account found in ALT, use the index
                        let mut index_bytes = [0u8; 32];
                        // Store the index in the first byte(s)
                        index_bytes[0] = index as u8;

                        LzAccountAlt {
                            index_or_pubkey: index_bytes,
                            is_signer: account.is_signer,
                            is_writable: account.is_writable,
                            is_alt_index: true,
                        }
                    }
                    None => {
                        // Account not found in ALT, use the pubkey
                        LzAccountAlt {
                            index_or_pubkey: account.pubkey.to_bytes(),
                            is_signer: account.is_signer,
                            is_writable: account.is_writable,
                            is_alt_index: false,
                        }
                    }
                }
            })
            .collect();

        Ok(lz_account_alts)
    }
}

/// same to anchor_lang::prelude::AccountMeta
#[derive(Clone, AnchorSerialize, AnchorDeserialize)]
pub struct LzAccountAlt {
    pub index_or_pubkey: [u8; 32],
    pub is_signer: bool,
    pub is_writable: bool,
    pub is_alt_index: bool,
}
